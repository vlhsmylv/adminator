import fs from "fs";
import { Schema } from "mongoose";
import path from "path";

interface Field {
  name: string;
  type: string;
  isPrimary: boolean;
  isAutogenerated: boolean;
  isArray?: boolean; // New property to indicate array (e.g., for one-to-many or many-to-many)
  minChar?: number;
  maxChar?: number;
}

interface SchemaDefinition {
  [key: string]: {
    description?: string;
    fields: Field[];
  };
}

// Map schema field type to Mongoose type
const mapTypeToMongoose = (
  type: string,
  isArray: boolean
): string | Record<string, any> => {
  const typeMap: Record<string, any> = {
    string: String,
    int: Number,
    float: Number,
    boolean: Boolean,
    date: Date,
    object: Object,
    array: Array,
  };
  const mongooseType = typeMap[type] || Schema.Types.ObjectId;
  return isArray ? [mongooseType] : mongooseType; // Wrap in array if it's a collection
};

// Map schema field type to TypeScript type
const mapTypeToTypeScript = (type: string, isArray: boolean): string => {
  const typeMap: Record<string, string> = {
    string: "string",
    int: "number",
    float: "number",
    boolean: "boolean",
    date: "Date",
    object: "Record<string, any>",
    array: "any[]",
  };
  const tsType = typeMap[type] || "Types.ObjectId"; // Use ObjectId for references
  return isArray ? `${tsType}[]` : tsType; // Add array notation if needed
};

// Handle the "id" field
const handleIdField = (fields: Field[]): Field[] => {
  return fields
    .filter((field) => field.name !== "id") // Exclude 'id' entirely
    .map((field) => {
      if (field.name === "id") {
        return { ...field, name: "_id" }; // Convert 'id' to '_id'
      }
      return field;
    });
};

// Safely write a file to disk
const safeWriteFile = (outputPath: string, content: string) => {
  try {
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, content, "utf-8");
  } catch (error: any) {
    console.error(`Error writing file ${outputPath}:`, error.message);
    throw error;
  }
};

// Generate DTOs from the schema
const generateDTOs = (schema: SchemaDefinition) => {
  Object.keys(schema).forEach((modelName) => {
    try {
      const { fields } = schema[modelName];
      const filteredFields = fields.filter((field) => field.name !== "id");

      const dtoFields = filteredFields
        .map(
          (field) =>
            `${field.name}: ${mapTypeToTypeScript(
              field.type,
              !!field.isArray
            )};`
        )
        .join("\n  ");

      const dtoString = `
import { Types } from "mongoose";

export interface I${modelName}DTO {
  ${dtoFields}
}
`;

      const dtoOutputPath = path.join(
        __dirname,
        "../dto",
        `${modelName}.dto.ts`
      );
      safeWriteFile(dtoOutputPath, dtoString);
      console.log(`DTO interface for ${modelName} written to ${dtoOutputPath}`);
    } catch (error: any) {
      console.error(`Error generating DTO for ${modelName}:`, error.message);
    }
  });
};

const getTypeName = (type: any): string => {
  if (Array.isArray(type)) {
    return `[${getTypeName(type[0])}]`; // Handle arrays recursively
  }
  if (type?.schemaName) {
    return `Schema.Types.${type.schemaName}`; // Mongoose-specific types
  }
  if (type?.name) {
    return type.name; // JavaScript constructor names (e.g., String, Number)
  }
  return "Unknown"; // Fallback
};

const parseFieldType = (
  type: string
): { isArray: boolean; baseType: string } => {
  const isArray = type.endsWith("[]"); // Check if the type ends with []
  const baseType = isArray ? type.slice(0, -2) : type; // Remove `[]` to get the base type
  return { isArray, baseType };
};

// Generate Mongoose models from the schema
const generateMongooseModel = (schema: SchemaDefinition) => {
  Object.keys(schema).forEach((modelName) => {
    try {
      let { fields } = schema[modelName];
      fields = handleIdField(fields);

      const fieldsAsString = fields
        .map((field) => {
          const { isArray, baseType } = parseFieldType(field.type); // Detect arrays and extract base type
          const mongooseType = mapTypeToMongoose(baseType, isArray);

          let fieldString;

          if (isArray) {
            // Correctly handle arrays with references or native types
            if (baseType === "User" || mongooseType === Schema.Types.ObjectId) {
              fieldString = `${field.name}: [{ type: Schema.Types.ObjectId, ref: '${baseType}' }]`;
            } else {
              fieldString = `${field.name}: [{ type: ${getTypeName(
                mongooseType
              )} }]`;
            }
          } else {
            // Handle single fields
            fieldString = `${field.name}: { type: ${getTypeName(mongooseType)}`;
            if (baseType === "User" || mongooseType === Schema.Types.ObjectId) {
              fieldString += `, ref: '${baseType}'`;
            }

            // Add other field properties for non-array fields
            if (field.isPrimary)
              fieldString += ", unique: true, required: true";
            if (field.isAutogenerated) fieldString += ", default: Date.now";
            if (field.minChar) fieldString += `, minlength: ${field.minChar}`;
            if (field.maxChar) fieldString += `, maxlength: ${field.maxChar}`;

            fieldString += " }"; // Close single field
          }

          return fieldString;
        })
        .join(",\n  ");

      const modelString = `
import { Schema, model, Types } from 'mongoose';
import { I${modelName}DTO } from '../dto/${modelName}.dto';

export interface I${modelName} extends I${modelName}DTO {
  _id?: Types.ObjectId;
}

const ${modelName}Schema = new Schema<I${modelName}>({
  ${fieldsAsString}
});

export const ${modelName} = model<I${modelName}>('${modelName}', ${modelName}Schema);
`;

      const modelOutputPath = path.join(
        __dirname,
        "../models",
        `${modelName}.model.ts`
      );
      safeWriteFile(modelOutputPath, modelString);
      console.log(
        `Mongoose model for ${modelName} written to ${modelOutputPath}`
      );
    } catch (error: any) {
      console.error(`Error generating model for ${modelName}:`, error.message);
    }
  });
};

// Main execution
try {
  const parsedSchemaPath = path.join(__dirname, "../schema/schema.parsed.json");
  if (!fs.existsSync(parsedSchemaPath)) {
    throw new Error(`Parsed schema file not found: ${parsedSchemaPath}`);
  }

  const schema: SchemaDefinition = JSON.parse(
    fs.readFileSync(parsedSchemaPath, "utf-8")
  );
  generateDTOs(schema);
  generateMongooseModel(schema);
} catch (error: any) {
  console.error("Fatal error:", error.message);
}
